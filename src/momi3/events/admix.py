"""Admixture events."""

from copy import deepcopy
from dataclasses import dataclass
from typing import Callable, TypeVar

import jax.numpy as jnp
import numpy as np

from momi3.common import Axes, PopCounter, Population, State, oe_einsum, unique_strs
from momi3.math_functions import convolve_sum, log_binom_pmf, log_hypergeom

from .event import Event

T = TypeVar("T")


@dataclass(frozen=True, kw_only=True)
class Pulse(Event):
    """A pulse of admixture between two populations in the same block.

    Args:
        source: population that donates lineages
        dest: population that receives lineages
        f_p: function that takes pd and returns the admixture proportion.

    Notes:
        See Lemma 2 of Kamm et al. (2020). The assumption that the populations are in the same block is critical.
        Otherwise, we model it is as admixture followed by split.
    """

    source: Population
    dest: Population
    f_p: Callable[[dict], float]

    def __post_init__(self):
        assert self.source != self.dest

    def _setup_impl(self, in_axes: Axes, ns: PopCounter) -> tuple[Axes, PopCounter, T]:
        """Compute the combinatorial factors that are constant for all values of p.

        Args:
            in_axes: dimensions of the child partial likelihood.
            ns: number of leaf samples with ancestry in each population

        Returns:
            dims: dimensions of the resulting partial likelihood.
            ns: counts of leaf lineages subtended by each population after pulse
            d: dict of hypergeometric sums needed to apply admixture lemma
        """
        # admixture works by sampling a fraction p of lineages from the donor population, 1 - p from the other. we model
        # this as a binomial draw, and then use the hypergeometric distribution to compute the probability of the
        # derived allele in the recipient population.
        # consistent with the notation in kamm et al 2020, we write
        nw1 = in_axes[self.dest] - 1
        nw2 = in_axes[self.source] - 1
        i, j, k = np.ogrid[: nw1 + nw2 + 1, : nw1 + 1, : nw2 + 1]
        aux = _admix_matrices(nw1)
        # this is basically copypasta fram split1. we let oe_einsum figure it all out.
        aux["H3"] = np.exp(log_hypergeom(M=nw1 + nw2, N=i, n=nw1, k=j)) * (
            i == j + k
        )  # [nw1+nw2+1, nw1+1, nw2+1]
        # axis computation
        new_ns = deepcopy(ns)
        # source is now ancestral to all the populations in the destination, too
        new_ns[self.source].update(new_ns[self.dest])
        # same idea for the out axes
        out_axes = deepcopy(in_axes)
        # the sample size of the source population increases to the size of all subntended
        # leaf populations
        n = sum(new_ns[self.source].values())
        out_axes[self.source] = n + 1
        aux.update({"in_axes": in_axes, "out_axes": out_axes})
        # downsample if necessary
        assert n <= nw1 + nw2
        if n < nw1 + nw2:
            # replaces the old code, B_plus = jnp.linalg.pinv(B), with QR. this is faster if we call repeatedly,
            # (and probably not slower since I think pinv does a QR anyways.)
            B = np.exp(
                log_hypergeom(
                    M=nw1 + nw2, N=i[..., 0], n=n, k=jnp.arange(n + 1)[None, :]
                )
            )  # [nw1+nw2+1, n + 1]
            aux["Bplus"] = np.linalg.pinv(B, rcond=1e-5)
        return out_axes, new_ns, aux

    def _execute_impl(self, st: State, params: dict, aux: T) -> State:
        """Pulse admixture when source and donor are in the same block.

        Args:
            st: State just before the admixing event.
            params: dictionary of parameters
            aux: dict of auxiliary data generated by setup function

        Returns:
            Likelihood of the parents just after the admixture event.

        Notes:
            See Lemma 2 of Kamm et al. (2020).
        """
        p = self.f_p(params)
        in_axes = aux["in_axes"]
        i = list(in_axes).index(self.dest)
        nw = st.pl.shape[i] - 1
        xw, j1, m1 = np.ogrid[(slice(None, nw + 1),) * 3]
        B = jnp.exp(log_binom_pmf(m1, nw, p))
        # C[j,k,u] is the probability of drawing u black balls from two urns when the total number of draws
        # from urn 1 is binomial(p) and the total number of black balls in the two urns are j and k respectively.
        C = convolve_sum(aux["H1"] * B, aux["H2"])[..., : nw + 1]
        # new axis names, these will be the things into which the dest population splits by admixing.
        a, b, c, d = unique_strs(in_axes, 4)
        # C_inds = [self.parent1, self.parent2, self.child]
        # (population a is what remains of dest after the admixture)
        C_inds = [b, a, self.dest]
        # now apply the "Split1" part. again cribbed from Split1.
        pl_inds = list(aux["in_axes"])
        out_inds = list(aux["out_axes"])
        j = out_inds.index(self.dest)
        out_inds[j] = a
        # axes of H3 are <num derived resulting pop, num derived in child1, num derived in child2>
        H3_inds = [c, b, self.source]
        # C splits dest into a and b, and then b merges with source via H3
        ein_args = (st.pl, pl_inds, C, C_inds, aux["H3"], H3_inds)
        i = out_inds.index(self.source)
        if "Bplus" in aux:  # and finally we hypergeom downsample
            out_inds[i] = d
            B_inds = [d, c]
            ein_args += (aux["Bplus"], B_inds)
            plp = oe_einsum(*ein_args, out_inds)
        else:
            out_inds[i] = c
            plp = oe_einsum(*ein_args, out_inds)
        return st._replace(pl=plp)


@dataclass(frozen=True, kw_only=True)
class Admix(Event):
    """Admixture event.

    Args:
        child: population that is result of admixture
        parent1: first parent population which donates a fraction p of alleles
        parent2: second parent population which donates a fraction 1-p of alleles
    """

    child: Population
    parent1: Population
    parent2: Population
    f_p: Callable[[dict], float]

    def __post_init__(self):
        assert (
            len({self.child, self.parent1, self.parent2}) == 3
        ), "admixture event must involve three populations"

    def _setup_impl(self, in_axes: Axes, ns: PopCounter) -> tuple[Axes, PopCounter, T]:
        """Setup admixture event

        Args:
            axes: axes of the incoming partial likelihood.
            ns: number of samples that each population is ancestral to.

        Returns:
            axes: axes of the resulting partial likelihood.
            ns: number of samples that each population is ancestral to after the admixture.
            aux: dict of hypergeometric sums needed to apply admixture lemma
        """
        # the three populations should all have different names.
        out_axes = deepcopy(in_axes)
        n_w = out_axes[self.child] - 1
        # delete the child first. this allows for one of the parents to have the same name as the child
        del out_axes[self.child]
        out_axes[self.parent1] = out_axes[self.parent2] = n_w + 1
        # each parent is now ancestral to the child populations
        nsp = deepcopy(ns)
        # _important_: delete nsp[child] first, because one of the parents might be the same as the child.
        del nsp[self.child]
        # then it will be re-added here:
        for p in self.parent1, self.parent2:
            nsp.setdefault(p, {})
            nsp[p].update(ns[self.child])
        # compute hypergeometric sums needed to apply admixture lemma
        aux = _admix_matrices(n_w)
        aux["in_axes"] = in_axes
        aux["out_axes"] = out_axes
        return out_axes, nsp, aux

    def _execute_impl(self, st: State, params: dict, aux: T) -> State:
        """Apply admixture event.

        Args:
            st: state of the partial likelihood.
            params: run-time parameter dict
            aux: auxiliary data for the admixture event.
        """
        p = self.f_p(params)
        in_axes = aux["in_axes"]
        # nw = in_axes[self.child] - 1
        nw = st.pl.shape[list(in_axes).index(self.child)] - 1
        xw, j1, m1 = np.ogrid[(slice(None, nw + 1),) * 3]
        B = jnp.exp(log_binom_pmf(m1, nw, p))
        # unpacking the next expression:
        # - (H1 * B)[xw, j1, m1] = prob of j1 black balls when there are xw black balls and nw total balls
        #   and m1 total draws, and m1 is distributed binomially with probability p
        # - From setup(), H2[xw,j2,nw-m1] is as described below.
        # - the convolve_sum() operation convolves (H1*B) and H2 along the last axis:
        #   C[j,k,l+m] += sum_n (B*H1)[j,l,n] * H2[k,m,n]
        #   this says that C[j,k,u] is the probability of drawing u black balls from two urns when the total
        #   number of draws from urn 1 is binomial(p) and the total number of black balls in the two urns
        #   are j and k respectively.
        C = convolve_sum(aux["H1"] * B, aux["H2"])
        C = C[
            :, :, : nw + 1
        ]  # slice down to nw + 1 because we can't draw more than that.
        assert C.shape == (nw + 1,) * 3
        pl_inds = list(in_axes)
        C_inds = [self.parent1, self.parent2, self.child]
        out_inds = list(aux["out_axes"])
        plp = oe_einsum(st.pl, pl_inds, C, C_inds, out_inds)
        return st._replace(pl=plp)


def _admix_matrices(nw: int) -> dict:
    xw, j1, m1 = np.ogrid[(slice(None, nw + 1),) * 3]
    m2 = nw - m1
    # H1[x,j,m] = prob of j black balls when there are x black balls and nw total balls and m total draws
    H1 = np.exp(log_hypergeom(n=xw, k=j1, M=nw, N=m1))
    # H2[x,j,m] = prob of j black balls when there are x black balls and nw total balls and nw - m total draws
    H2 = np.exp(log_hypergeom(n=xw, k=j1, M=nw, N=m2))
    return {"H1": H1, "H2": H2}
