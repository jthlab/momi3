"""Merge two populations in the same event block"""
from copy import deepcopy
from dataclasses import dataclass
from typing import TypeVar

import numpy as np
from jax import lax
from jax import numpy as jnp

from momi3.common import Axes, PopCounter, Population, State, oe_einsum, unique_str
from momi3.math_functions import log_hypergeom

T = TypeVar("T")


@dataclass
class Split1:
    """Merge two populations in the same event block.

    Attributes:
        donor: first population which gets merged into recipient (backwards in time)
        recipient: population which receives lineages from donor

    Notes:
        After the merge, the donor population is removed from the partial likelihood.
    """

    donor: Population
    recipient: Population

    def __post_init__(self):
        assert self.donor != self.recipient

    def setup(self, in_axes: Axes, ns: PopCounter) -> tuple[Axes, PopCounter, T]:
        """Setup for the split1 lemma.

        Args:
            in_axes: axes of the child partial likelihood.
            ns: number of samples subtended by each population.

        Returns:
            axes: dimensions of the pl after the split event
            aux: auxiliary data

        Notes:
            pop2 is merged into pop1. The merged population resides in pop1.
        """
        nw1 = in_axes[self.donor] - 1
        nw2 = in_axes[self.recipient] - 1
        i, j, k = np.ogrid[: nw1 + nw2 + 1, : nw1 + 1, : nw2 + 1]
        # update population counts
        nsp = deepcopy(ns)
        nsp[self.recipient].update(nsp[self.donor])
        del nsp[self.donor]
        n = sum(
            nsp[self.recipient].values()
        )  # total number of lineages which recipient is now ancestral to
        # resulting axes, same thing
        out_axes = in_axes.copy()
        del out_axes[self.donor]
        # deleting and then re-adding ensures that recipient is the last axis. this enables us to easily apply
        # the hypergeom inverse in execute() by treating the leading axes as batch dimensions.
        del out_axes[self.recipient]
        out_axes[self.recipient] = n + 1
        # compute aux
        H = np.exp(log_hypergeom(M=nw1 + nw2, N=i, n=nw1, k=j)) * (
            i == j + k
        )  # [nw1+nw2+1, nw1+1, nw2+1]
        aux = {"in_axes": in_axes, "out_axes": out_axes, "H": H}
        # downsample if necessary
        assert n <= nw1 + nw2
        if n < nw1 + nw2:
            # replaces the old code, B_plus = jnp.linalg.pinv(B), with QR. this is faster if we call repeatedly,
            # (and probably not slower since I think pinv does a QR anyways.)
            B = np.exp(
                log_hypergeom(
                    M=nw1 + nw2, N=i[..., 0], n=n, k=jnp.arange(n + 1)[None, :]
                )
            )  # [nw1+nw2+1, n + 1]
            aux["Q"], aux["R"] = np.linalg.qr(B)
        return out_axes, nsp, aux

    def execute(self, st: State, params: dict, aux: T) -> State:
        """Merge pop2 into pop1 when they are both in the same event block.

        Args:
            st: state just before the merge event
            params: dict of parameters
            f: not used
            aux: dict of auxiliary data generated by setup

        Return:
            State after the merge event.
        """
        pl_inds = list(aux["in_axes"])
        a = unique_str(pl_inds)
        out_inds = list(aux["out_axes"])
        i = out_inds.index(self.recipient)
        out_inds[i] = a
        assert (
            i == len(out_inds) - 1
        )  # this axis should be innermost for doing the quasi-inverse below
        if "Q" in aux:
            # B = QR so B+X = solve(R, Q.T B)
            # hypergeometrically upsample (forwards in time) to go from n to nw1 + nw2
            b = unique_str(out_inds)
            Q_inds = [b, a]
            H_inds = [b, self.donor, self.recipient]
            y = oe_einsum(aux["Q"], Q_inds, aux["H"], H_inds, st.pl, pl_inds, out_inds)

            # assert y.shape == tuple(aux["out_axes"].values())
            # triangular_solve wants y to come as a column vector, so we have to add and strip off a trailing axis
            def f(yi):
                return lax.linalg.triangular_solve(
                    aux["R"], yi[:, None], left_side=True, lower=False
                )[:, 0]

            # clip because inverting R can lead to small negative values
            plp = jnp.apply_along_axis(f, i, y).clip(1e-20)
        else:
            H_inds = [a, self.donor, self.recipient]
            plp = oe_einsum(aux["H"], H_inds, st.pl, pl_inds, out_inds)
        return st._replace(pl=plp)
